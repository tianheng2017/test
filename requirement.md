有各种不同的销售方案被用来以卖家获得最高利润的方式出售商品。英式拍卖，用于在澳大利亚售卖房地产，可能是最为人熟悉的：竞拍者轮流报出越来越高的价格，直到只剩下一个报价最高的竞拍者，而没有其他竞拍者愿意再报更高的价格。然后，拍卖师宣布拍卖结束，最高竞价者被宣布为成功买家，价格等于他们的最高出价。

从未获胜的竞拍者的角度来看，这种方法有一些缺点。在拍卖过程中，他们需要透露他们愿意支付的最高价格。其他想要销售类似物品的卖家可以利用这一事实，拒绝以低于这个价格的价格出售，剥夺了购买者以更低价格购买的可能性，即使没有其他竞拍者的竞争。如果能以一种不揭示失败竞标者出价的方式确定拍卖的获胜竞标者，那就更好了。在本次作业的第一部分中，我们将开发一种实现这种方式的方法。如果还能隐藏失败竞标者的身份，那就更好了。这将在本次作业的第二部分的一个目标中解决。

通过使用荷兰式拍卖，可以实现隐藏未获胜竞标者的出价。这种拍卖交换了买方和卖方的角色，并通过不断降低价格的方式进行，直到找到愿意以该价格购买的买家为止。也就是说，卖家首先报出高价，并要求买家以该价格购买。如果没有买家表示愿意以该价格购买，卖家将降低价格，并再次要求出价。这个过程重复进行，价格随着时间的推移而下降，直到找到一个买家。

在本次作业中，我们将应用这种方法开发一个智能合约，用于在其中可以购买和出售 ERC-20 代币的市场。在这个智能合约市场中，我们将应用这种方法来购买和出售 ERC-20 代币。与单个商品的销售相比，我们有一些额外的要求。考虑这样一种情况，卖方希望出售相同类型的 N 个 ERC-20 代币。假设有 n ≥ 1 个竞标者，所有竞标者都提供以每个代币的当前卖家价格 p 购买 b1，. . . ，bn 个代币的报价。竞标者 i 可以从该卖家获得 ≤ bi 个代币。当从该卖家获得 x 个代币时，竞标者 i 将以每个代币的价格 p 支付，总成本为 x × p。

• 如果 P i=1...n bi ≤ N，则每个买家 i 应该精确地获得 bi 个代币，剩余的 N − P i=1...n bi 个代币待售。如果卖家愿意，他们可以选择进一步降低价格来出售这些代币。

• 如果 P i=1...n bi > N，则代币的销售存在争议，我们需要一条规则来确定每个买家应该收到多少个代币。我们将采取这样的态度：等待购买时间最长的买家将首先获得订单。为此，我们需要一种确定哪个买家是等待时间最长的方法，而不会过早地透露他们准备支付的价格。我们通过使用盲竞标来解决这个问题。我们最初维护一个计数器 bid-number，其初始值为 0。当买家提交购买订单时，它将被分配当前的 bid-number，并递增 bid-number。竞标本身是盲目的：它不应透露买家准备购买的代币数量，也不应透露他们准备为每个代币支付的价格。当卖家的价格达到买家准备支付的价格时，买家会打开或透露他们的竞标，使代币数量和价格公开。买家不应能够通过透露与他们最初的盲竞标中使用的数字不同的代币数量或价格来作弊。

在提供多个卖家和买家匹配的市场服务背景下，当多个卖家以潜在不同的价格出售相同种类的代币时，也存在类似的问题。发行自同一智能合约的 ERC-20 代币是可以互换的，因此买家不会关心他们收到哪个卖家的代币。在匹配买入订单和卖出报价时，应优先将订单与最低价格的卖出报价匹配。对于相同价格的卖出报价，应该优先使用早期的卖出报价来提供给买家。为了实现这一点，当代币块第一次被提供出售时，它将与一个报价号关联。

请注意，在价格为 p 的卖出报价与价格为 q ≥ p 的买入订单匹配时，买家支付更低的价格 p。买入价格为 q 的订单不应与价格为 p > q 的卖出报价匹配：这样的公开买入订单会留在市场上，以便在后续回合中可能匹配。

例如，假设在某个匹配回合中，我们有以下相同代币类型的卖出报价和公开买入订单：

• 卖家1以每个价格为3个 ETH的价格提供5个代币，带有报价号1。 • 卖家2以每个价格为2个 ETH的价格提供10个代币，带有报价号2。 • 买家3以每个价格为3个 ETH的价格竞标5个代币，带有竞标号1。 • 买家4以每个价格为2个 ETH的价格竞标20个代币，带有竞标号2。

然后：

• 最老的竞标是买家3。他们的竞标与卖家2的价格较低的报价匹配，买家3以每个2个 ETH的价格收到5个代币。这样，卖家2的报价还剩下5个代币。 • 接下来处理买家4的竞标。他们以每个2个 ETH的价格从卖家2的报价中收到5个代币，以每个3个 ETH的价格从卖家1的报价中收到5个代币。也就是说，他们以总费用为 10 + 15 = 25 个 ETH 收到了10个代币。 • 买家4的竞标没有完全填满，因此保留为一个以每个2个 ETH的价格买入10个代币的竞标，除非买家4在下一个竞标开放回合期间选择撤回该报价。



Part 1（25分）

开发一个Solidity语言的DutchMarket智能合约，实现ERC-20代币市场并实现上述想法。具体来说，合约应具备以下功能：

• 买方和卖方应能够在智能合约中创建账户，其中包含一定数量的ETH和不同种类的ERC-20代币。（代币种类由发行代币的智能合约的地址标识。）

• 市场中持有的ERC-20代币应受DutchMarket合约的控制，以防它们被在其他地方出售。

• 买方和卖方应能够从其账户中存取和提取代币和ETH货币。

• 卖方应能够提供在其账户中的一块N个相同种类的代币，以指定的价格出售。

• 卖方应能够降低挂单的价格，但不能增加价格。

• 卖方应能够撤销挂单。

• 买方应能够以盲目出价的方式购买代币。出价规定了购买的代币类型、要购买的代币数量以及最高价格。任何监控区块链的人都不能推断出出价的这些细节。但是，出价人的加密地址可以被揭示（请参见下一节，该节涉及出价人身份的隐藏）。

• 当卖方将价格降低到买方愿意支付的金额时，买方可以通过开放相应的盲目出价来完成交易。这将揭示代币类型、代币数量和最高价格。

• 一旦购买挂单被开放，它就会一直保持开放状态。

• 买方可以撤回开放或关闭的购买挂单。

• 市场按照Deposit/Withdraw，Offer，Bid Opening和Matching的重复模式运行，每个模式的操作限制了参与者在该模式下可以执行的操作。每个模式的执行时间为5分钟，在此之后，市场会转到序列中的下一个模式（匹配后是Deposit/Withdraw）。每个模式中允许的操作如下：

- Deposit/Withdraw：买方和卖方可以从其账户中存入和提取资金。

- Offer：卖方可以提供新的出售挂单，撤回挂单，并降低现有出售挂单的价格。

- Bid Opening：买方可以以盲目出价的方式提出新的购买挂单。买方也可以开放盲目出价。买方还可以撤回开放或盲目出价。

- Matching：根据第1节中描述的优先规则，将出售挂单与购买挂单进行匹配。

- 在Deposit/Withdraw（存款/取款）模式下，买家和卖家可以从他们的账户中存款和取款。

-   在Offer（出价）模式下，卖家可以提供出售同一种类的N个代币，以指定的价格进行出售。 

-  在Offer模式下，卖家可以降低未完成出价的价格，但不可以增加价格。 

- 在Offer模式下，卖家可以撤回出售报价。 

-  在Bid Opening（出价公开）模式下，买家可以提交新的盲出价并进行开盘。买家也可以撤回开放或盲出价。 

- 在Matching（匹配）模式下，未完成的出售报价与已开放的买入盲出价按照第1节中描述的优先规则进行匹配。 

-  对于每个匹配对，应将相应数量的代币k从卖家的账户转移到买家的账户，并将k倍的报价从买家的账户转移到卖家的账户。（该服务不向买家和卖家收取市场费用。） 

-  禁止负账户余额。如果执行匹配会在买家或卖家的账户中产生负余额，则不执行该匹配。尽可能地，市场设计应防止这种不当匹配的可能性。 

-  尽可能地，智能合约的实现应最小化用户（买家和卖家）需要支付的交易的燃气成本。

  

Part 2 - Stretch Goal (10 Marks)

如上所述，盲拍仍会暴露出投标人的身份，至少通过他们的以太坊地址，因为用户将使用该地址开设帐户，然后向市场智能合约提交用该地址的密钥签名的竞标交易。这可能会影响投标人的隐私，其他投标人可能不愿投标，当他们看到有一位竞争者拥有大量现金余额或声誉很高时。

作为一个 stretch goal，修改你的解决方案，允许通过以下技术模糊竞标人身份。用户可以使用使用另一个地址 B 签署的交易来提交盲拍，而不是使用他们在市场上开设的带有地址 A 的帐户签署的交易。这些盲拍通常陈述了令牌类型、代币数量和价格。然而，除此之外，投标还指出了真实投标人 A 的地址。在盲拍被公开之前，所有这些信息（除了 B）都应该隐藏起来。在公开的时候，应该公开正常的投标信息，以及 A 的地址，以便投标的匹配会以正常的方式影响 A 的帐户。

请注意，在公开这样一个竞标的时候，所公开的信息应该证明，确实是 A 意图使用 B 签署的交易提交了盲拍。除了真实投标人 A 之外，任何用户都不应该使用这种机制来导致 A 帐户的变化。为此，在投标公开之前，应该由 A 的地址签署的消息来验证投标的有效性。这个机制就像是盲拍是带有签名信封的信件一样。

提示：以太坊函数 ecrecover 和框架，如 Web3.py 或 Web3.js，与此部分有关。您还可以调查提案，如 EIP-721 和 EIP-2612。

交付成果

提交以下内容。请注意，本次任务不要求为该应用程序开发图形用户界面 - 在需要代码以外的代码时，使用命令行指令调用即可满足要求。

1.（8分）报告（PDF格式），描述您的整个系统的设计和实现。 报告应 •描述数据模型以及您如何选择使用Solidity数据结构来实现此设计。 •如果使用智能合约需要在智能合约之外进行离线计算，请解释此代码的功能以及如何编译和/或操作它。在本任务中，您无需为任何此类代码开发复杂的用户界面：一些简单的命令行脚本就足以满足要求。 •对于上述每个要求，简要说明代码如何满足要求以及代码中每个功能的简要说明。如果在分析应用程序过程中识别到任何缺失的要求或规范模糊不清的情况，请说明这些缺失以及您已采取的措施来解决和实施它们。 •从买家和卖家的角度分析应用程序的运行成本，以及这取决于诸如总投标和要约数量等因素。考虑当前有关在以太坊公共区块链上进行交易的成本和运行代码的燃气成本的信息。 •描述您认为应向用户指出的有关系统及其操作的任何安全注意事项。用户在使用系统时是否有任何特定陷阱需要避免，如果有，用户可以采用什么策略来避免这些陷阱。 •解释您的代码如何避免常见的Solidity安全漏洞，例如重入攻击。 •反思性地讨论以太坊平台是否适合此应用程序。

必须正确引用您在项目中使用的任何信息来源或库。

2.（10分）提交包含所有Solidity和辅助代码的目录，以使用Truffle构建和运行您的实现。 特别是应有一个名为contracts的目录，其中包含用于实现基本功能的Solidity智能合约。您的代码应有良好的文档。

如果您使用了任何公共JavaScript库，为避免提交文件过大，不要包含这些库，但确保提交中包含足够的信息，可以自动安装这些库。特别地，包括package-lock.json文件。

3.（7分）包括一个目录test，其中包含用于验证智能合约实现正确性的测试用例。您的报告应描述您采用的测试方法，并总结您构建的测试场景。使用Truffle测试框架执行您的测试应该是可行的。您也可以通过运行Ethereum区块链的Ganache实例进行测试。如果需要特定的命令行参数来运行您的测试，请包含一个脚本，以便评分人员可以轻松地进行适当的调用。在任何情况下，报告应包含确定如何运行您的测试所需的所有信息。

4.（10分）一旦您完成了基本要求，尝试完成拓展目标。如果您尝试了此部分，您的报告应包含一个描述您所做的内容的部分，您应该为该功能包括测试用例，并且从您的报告中清楚地了解如何运行这些测试用例。